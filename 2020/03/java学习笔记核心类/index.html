<!doctype html><html lang=zh><head><title>Java学习笔记——核心类 - 胡思乱想集散中心</title><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,minimal-ui"><meta name=renderer content="webkit"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="black"><meta name=format-detection content="telephone=no,email=no,adress=no"><meta name=theme-color content="#000000"><meta http-equiv=window-target content="_top"><meta name=description content="上一篇记录了Java的面向对象的语法，这篇来一点常用的核心类。
"><meta name=generator content="Hugo 0.99.1 with theme pure"><title>Java学习笔记——核心类 - 胡思乱想集散中心</title><link rel=stylesheet href=https://qeryu.github.io/css/style.min.084a5eb24fb0cf9d5aade7246f19ba0c820cf904996a28ffe88039427693ac68.css><link rel=stylesheet href=https://cdn.staticfile.org/highlight.js/9.15.10/styles/github.min.css async><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css async><meta property="og:title" content="Java学习笔记——核心类"><meta property="og:description" content="上一篇记录了Java的面向对象的语法，这篇来一点常用的核心类。"><meta property="og:type" content="article"><meta property="og:url" content="https://qeryu.github.io/2020/03/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%A0%B8%E5%BF%83%E7%B1%BB/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-03-26T14:51:15+00:00"><meta property="article:modified_time" content="2020-03-26T14:51:15+00:00"><meta itemprop=name content="Java学习笔记——核心类"><meta itemprop=description content="上一篇记录了Java的面向对象的语法，这篇来一点常用的核心类。"><meta itemprop=datePublished content="2020-03-26T14:51:15+00:00"><meta itemprop=dateModified content="2020-03-26T14:51:15+00:00"><meta itemprop=wordCount content="6813"><meta itemprop=keywords content="Java,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Java学习笔记——核心类"><meta name=twitter:description content="上一篇记录了Java的面向对象的语法，这篇来一点常用的核心类。"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body class="main-center theme-black" itemscope itemtype=http://schema.org/WebPage><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=slimContent><div class=navbar-header><div class="profile-block text-center"><a id=avatar href=https://github.com/qeryu target=_blank><img class="img-circle img-rotate" src=https://qeryu.github.io/avatar/qeryu.jpg width=200 height=200></a><h2 id=name class="hidden-xs hidden-sm">Qeryu</h2><h3 id=title class="hidden-xs hidden-sm hidden-md">信息安全学生</h3><small id=location class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i>Wuhan, China</small></div><div class=search id=search-form-wrap><form class="search-form sidebar-form"><div class=input-group><input type=text class="search-form-input form-control" placeholder=搜索>
<span class=input-group-btn><button type=submit class="search-form-submit btn btn-flat" onclick=return!1><i class="icon icon-search"></i></button></span></div><div class=ins-search><div class=ins-search-mask></div><div class=ins-search-container><div class=ins-input-wrapper><input type=text class=ins-search-input placeholder=想要查找什么... x-webkit-speech>
<button type=button class="close ins-close ins-selectable" data-dismiss=modal aria-label=Close><span aria-hidden=true>×</span></button></div><div class=ins-section-wrapper><div class=ins-section-container></div></div></div></div></form></div><button class="navbar-toggle collapsed" type=button data-toggle=collapse data-target=#main-navbar aria-controls=main-navbar aria-expanded=false>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span></button></div><nav id=main-navbar class="collapse navbar-collapse" itemscope itemtype=http://schema.org/SiteNavigationElement role=navigation><ul class="nav navbar-nav main-nav"><li class="menu-item menu-item-home"><a href=/><i class="icon icon-home-fill"></i>
<span class=menu-title>Home</span></a></li><li class="menu-item menu-item-archives"><a href=/posts/><i class="icon icon-archives-fill"></i>
<span class=menu-title>Archives</span></a></li><li class="menu-item menu-item-categories"><a href=/categories/><i class="icon icon-folder"></i>
<span class=menu-title>Categories</span></a></li><li class="menu-item menu-item-tags"><a href=/tags/><i class="icon icon-tags"></i>
<span class=menu-title>Tags</span></a></li><li class="menu-item menu-item-about"><a href=/about/><i class="icon icon-cup-fill"></i>
<span class=menu-title>About</span></a></li></ul></nav></div></header><aside class=sidebar itemscope itemtype=http://schema.org/WPSideBar><div class=slimContent><div class=widget><h3 class=widget-title>公告</h3><div class=widget-body><div id=board><div class=content><p>enjoy~</p></div></div></div></div><div class=widget><h3 class=widget-title>标签</h3><div id=tag-cloud-list class=widget-body><a href=https://qeryu.github.io/tags/arp-spoofing/ class=tag-list-link rel=1>arp-spoofing<span class=tag-list-count>1</span></a>
<a href=https://qeryu.github.io/tags/beego/ class=tag-list-link rel=1>beego<span class=tag-list-count>1</span></a>
<a href=https://qeryu.github.io/tags/blog/ class=tag-list-link rel=2>blog<span class=tag-list-count>2</span></a>
<a href=https://qeryu.github.io/tags/c++/ class=tag-list-link rel=1>c++<span class=tag-list-count>1</span></a>
<a href=https://qeryu.github.io/tags/coolq/ class=tag-list-link rel=1>coolq<span class=tag-list-count>1</span></a>
<a href=https://qeryu.github.io/tags/dns/ class=tag-list-link rel=1>dns<span class=tag-list-count>1</span></a>
<a href=https://qeryu.github.io/tags/docker/ class=tag-list-link rel=2>docker<span class=tag-list-count>2</span></a>
<a href=https://qeryu.github.io/tags/eslint/ class=tag-list-link rel=1>eslint<span class=tag-list-count>1</span></a>
<a href=https://qeryu.github.io/tags/fuzzing/ class=tag-list-link rel=3>fuzzing<span class=tag-list-count>3</span></a>
<a href=https://qeryu.github.io/tags/git/ class=tag-list-link rel=1>git<span class=tag-list-count>1</span></a>
<a href=https://qeryu.github.io/tags/golang/ class=tag-list-link rel=1>golang<span class=tag-list-count>1</span></a>
<a href=https://qeryu.github.io/tags/java/ class=tag-list-link rel=3>java<span class=tag-list-count>3</span></a>
<a href=https://qeryu.github.io/tags/javascript/ class=tag-list-link rel=2>javascript<span class=tag-list-count>2</span></a>
<a href=https://qeryu.github.io/tags/kali/ class=tag-list-link rel=1>kali<span class=tag-list-count>1</span></a>
<a href=https://qeryu.github.io/tags/linux/ class=tag-list-link rel=1>linux<span class=tag-list-count>1</span></a>
<a href=https://qeryu.github.io/tags/lstm/ class=tag-list-link rel=2>lstm<span class=tag-list-count>2</span></a>
<a href=https://qeryu.github.io/tags/maven/ class=tag-list-link rel=1>maven<span class=tag-list-count>1</span></a>
<a href=https://qeryu.github.io/tags/metasploit/ class=tag-list-link rel=1>metasploit<span class=tag-list-count>1</span></a>
<a href=https://qeryu.github.io/tags/metasploit3/ class=tag-list-link rel=1>metasploit3<span class=tag-list-count>1</span></a>
<a href=https://qeryu.github.io/tags/montage/ class=tag-list-link rel=1>montage<span class=tag-list-count>1</span></a>
<a href=https://qeryu.github.io/tags/nmap/ class=tag-list-link rel=1>nmap<span class=tag-list-count>1</span></a>
<a href=https://qeryu.github.io/tags/patch/ class=tag-list-link rel=1>patch<span class=tag-list-count>1</span></a>
<a href=https://qeryu.github.io/tags/pe%E6%96%87%E4%BB%B6/ class=tag-list-link rel=1>pe文件<span class=tag-list-count>1</span></a>
<a href=https://qeryu.github.io/tags/pwn/ class=tag-list-link rel=1>pwn<span class=tag-list-count>1</span></a>
<a href=https://qeryu.github.io/tags/python/ class=tag-list-link rel=2>python<span class=tag-list-count>2</span></a>
<a href=https://qeryu.github.io/tags/re/ class=tag-list-link rel=1>re<span class=tag-list-count>1</span></a>
<a href=https://qeryu.github.io/tags/ret2libc/ class=tag-list-link rel=2>ret2libc<span class=tag-list-count>2</span></a>
<a href=https://qeryu.github.io/tags/rnn/ class=tag-list-link rel=1>rnn<span class=tag-list-count>1</span></a>
<a href=https://qeryu.github.io/tags/scapy/ class=tag-list-link rel=1>scapy<span class=tag-list-count>1</span></a>
<a href=https://qeryu.github.io/tags/seccomp/ class=tag-list-link rel=1>seccomp<span class=tag-list-count>1</span></a>
<a href=https://qeryu.github.io/tags/seed/ class=tag-list-link rel=1>seed<span class=tag-list-count>1</span></a>
<a href=https://qeryu.github.io/tags/semanticfuzzing/ class=tag-list-link rel=1>semanticfuzzing<span class=tag-list-count>1</span></a>
<a href=https://qeryu.github.io/tags/syn-flooding/ class=tag-list-link rel=1>syn-flooding<span class=tag-list-count>1</span></a>
<a href=https://qeryu.github.io/tags/tls/ssl-vpn/ class=tag-list-link rel=1>tls/ssl-vpn<span class=tag-list-count>1</span></a>
<a href=https://qeryu.github.io/tags/v2ray/ class=tag-list-link rel=1>v2ray<span class=tag-list-count>1</span></a>
<a href=https://qeryu.github.io/tags/vim/ class=tag-list-link rel=1>vim<span class=tag-list-count>1</span></a>
<a href=https://qeryu.github.io/tags/wordpress/ class=tag-list-link rel=1>wordpress<span class=tag-list-count>1</span></a>
<a href=https://qeryu.github.io/tags/xml/ class=tag-list-link rel=1>xml<span class=tag-list-count>1</span></a>
<a href=https://qeryu.github.io/tags/zest/ class=tag-list-link rel=2>zest<span class=tag-list-count>2</span></a>
<a href=https://qeryu.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ class=tag-list-link rel=1>学习笔记<span class=tag-list-count>1</span></a>
<a href=https://qeryu.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/ class=tag-list-link rel=1>渗透测试<span class=tag-list-count>1</span></a>
<a href=https://qeryu.github.io/tags/%E7%88%AC%E8%99%AB/ class=tag-list-link rel=1>爬虫<span class=tag-list-count>1</span></a>
<a href=https://qeryu.github.io/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/ class=tag-list-link rel=1>科学上网<span class=tag-list-count>1</span></a>
<a href=https://qeryu.github.io/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/ class=tag-list-link rel=1>论文阅读<span class=tag-list-count>1</span></a></div><script>document.onreadystatechange=()=>{document.readyState==="complete"&&tagCloud("#tag-cloud-list a",8,20)};function tagCloud(n,s,o){let t=0,e=0;$(n).each(function(){let n=Number($(this).attr("rel"));t<n&&(t=n),(e>n||e==0)&&(e=n)});let i=(o-s)/(t-e);$(n).each(function(){let t=$(this).attr("rel")-e;$(this).css({"font-size":s+t*i+"px"})})}</script></div><div class=widget><h3 class=widget-title>分类</h3><div class=widget-body><ul class=category-list><li class=category-list-item><a href=https://qeryu.github.io/categories/cs61a/ class=category-list-link>cs61a</a><span class=category-list-count>1</span></li><li class=category-list-item><a href=https://qeryu.github.io/categories/fuzzing/ class=category-list-link>fuzzing</a><span class=category-list-count>3</span></li><li class=category-list-item><a href=https://qeryu.github.io/categories/javascrip/ class=category-list-link>javascrip</a><span class=category-list-count>1</span></li><li class=category-list-item><a href=https://qeryu.github.io/categories/lab/ class=category-list-link>lab</a><span class=category-list-count>5</span></li><li class=category-list-item><a href=https://qeryu.github.io/categories/language/ class=category-list-link>language</a><span class=category-list-count>3</span></li><li class=category-list-item><a href=https://qeryu.github.io/categories/linux/ class=category-list-link>linux</a><span class=category-list-count>1</span></li><li class=category-list-item><a href=https://qeryu.github.io/categories/lstm/ class=category-list-link>lstm</a><span class=category-list-count>1</span></li><li class=category-list-item><a href=https://qeryu.github.io/categories/machine-learning/ class=category-list-link>machine-learning</a><span class=category-list-count>1</span></li><li class=category-list-item><a href=https://qeryu.github.io/categories/notes/ class=category-list-link>notes</a><span class=category-list-count>3</span></li><li class=category-list-item><a href=https://qeryu.github.io/categories/web/ class=category-list-link>web</a><span class=category-list-count>6</span></li><li class=category-list-item><a href=https://qeryu.github.io/categories/xml/ class=category-list-link>xml</a><span class=category-list-count>1</span></li><li class=category-list-item><a href=https://qeryu.github.io/categories/%E7%BD%91%E5%AE%89%E5%AE%9E%E8%B7%B5/ class=category-list-link>网安实践</a><span class=category-list-count>1</span></li></ul></div></div><div class=widget><h3 class=widget-title>最新文章</h3><div class=widget-body><ul class="recent-post-list list-unstyled no-thumbnail"><li><div class=item-inner><p class=item-title><a href=https://qeryu.github.io/2022/05/cse_lab3_5/ class=title>网络安全综合实践lab3 5</a></p><p class=item-date><time datetime="2022-05-23 20:22:03 +0800 +0800" itemprop=datePublished>2022-05-23</time></p></div></li><li><div class=item-inner><p class=item-title><a href=https://qeryu.github.io/2022/05/infosec_homework2/ class=title>信息系统安全Lab2</a></p><p class=item-date><time datetime="2022-05-20 08:40:30 +0800 +0800" itemprop=datePublished>2022-05-20</time></p></div></li><li><div class=item-inner><p class=item-title><a href=https://qeryu.github.io/2022/05/cse_lab3_3/ class=title>网络安全综合实践Lab3-3</a></p><p class=item-date><time datetime="2022-05-18 14:38:48 +0800 +0800" itemprop=datePublished>2022-05-18</time></p></div></li><li><div class=item-inner><p class=item-title><a href=https://qeryu.github.io/2022/05/cse_lab3_2/ class=title>网络安全综合实践Lab3-2</a></p><p class=item-date><time datetime="2022-05-11 14:44:19 +0800 +0800" itemprop=datePublished>2022-05-11</time></p></div></li><li><div class=item-inner><p class=item-title><a href=https://qeryu.github.io/2022/05/netsec_lab3/ class=title>计算机网络安全Lab3</a></p><p class=item-date><time datetime="2022-05-07 13:20:56 +0800 +0800" itemprop=datePublished>2022-05-07</time></p></div></li></ul></div></div></div></aside><aside class="sidebar sidebar-toc collapse" id=collapseToc itemscope itemtype=http://schema.org/WPSideBar><div class=slimContent><h4 class=toc-title>文章目录</h4><nav id=toc class="js-toc toc"></nav></div></aside><main class=main role=main><div class=content><article id=- class="article article-type-" itemscope itemtype=http://schema.org/BlogPosting><div class=article-header><h1 itemprop=name><a class=article-title href=/2020/03/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%A0%B8%E5%BF%83%E7%B1%BB/>Java学习笔记——核心类</a></h1><div class=article-meta><span class=article-date><i class="icon icon-calendar-check"></i>&nbsp;
<a href=https://qeryu.github.io/2020/03/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%A0%B8%E5%BF%83%E7%B1%BB/ class=article-date><time datetime="2020-03-26 14:51:15 +0000 UTC" itemprop=datePublished>2020-03-26</time></a></span>
<span class=article-category><i class="icon icon-folder"></i>&nbsp;
<a class=article-category-link href=/categories/language/>Language</a></span>
<span class=article-tag><i class="icon icon-tags"></i>&nbsp;
<a class=article-tag-link href=/tags/java/>Java</a></span>
<span class="post-wordcount hidden-xs" itemprop=wordCount>字数统计: 6813字</span>
<span class="post-readcount hidden-xs" itemprop=timeRequired>阅读时长: 14分</span></div></div><div class="article-entry marked-body js-toc-content" itemprop=articleBody><p>上一篇记录了Java的面向对象的语法，这篇来一点常用的核心类。</p><h1 id=string类>String类</h1><p>感觉一个一个描述蛮蠢的，直接上表吧，方便快查</p><table><thead><tr><th style=text-align:left>方法原型</th><th>方法描述</th></tr></thead><tbody><tr><td style=text-align:left><code>static String copyValueOf(char[] data)</code></td><td>返回指定数组中表示该字符序列的 String</td></tr><tr><td style=text-align:left><code>static String copyValueOf(char[] data, int offset, int count)</code></td><td>返回指定数组中表示该字符序列的 String</td></tr><tr><td style=text-align:left><code>void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)</code></td><td>将字符从此字符串复制到目标字符数组。</td></tr><tr><td style=text-align:left><code>String intern()</code></td><td>返回字符串对象的规范化表示形式</td></tr></tbody></table><h2 id=字符串比较>字符串比较</h2><table><thead><tr><th>子串比较方法</th><th>方法解释</th></tr></thead><tbody><tr><td><code>int compareTo(Object o)</code></td><td>把这个字符串和另一个对象比较</td></tr><tr><td><code>int compareTo(String other)</code></td><td>按字典顺序比较两个字符串</td></tr><tr><td><code>int compareToIgnoreCase(String str)</code></td><td>按字典顺序比较两个字符串，不考虑大小写</td></tr><tr><td><code>boolean equals(Object anObject)</code></td><td>将此字符串与指定的对象比较。</td></tr><tr><td><code>boolean equalsIgnoreCase(String other)</code></td><td>将此 String 与另一个 String 比较，不考虑大小写。</td></tr><tr><td><code>boolean contentEquals(StringBuffer sb)</code></td><td>字符串与指定的<code>StringBuffer</code>有相同顺序的字符时候返回真</td></tr></tbody></table><p>除了这些整体比较以及上文的正则表达式匹配之外，还有直接比较两个字符串子串的方法</p><pre><code class=language-java>boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)
/* 测试两个字符串区域是否相等
    ignoreCase: 	是否忽略大小写
    toffset: 		使用方法的字符串中，待比较子串起始位置的偏移量
    other: 			与之比较的另一个字符串
    ooffset: 		other字符串中，待比较子串起始位置的偏移量
    len: 			比较的子串的长度 */
boolean regionMatches(int toffset, String other, int ooffset, int len)
// 同上，少了一个参数
</code></pre><h3 id=stringbuffer与stringbuilder>StringBuffer与StringBuilder</h3><p>和 String 类不同的是，<code>StringBuffer</code> 和 <code>StringBuilder</code> 类的对象能够被多次的修改，并且不产生新的未使用对象。一般在代码中出现，多次使用 + 拼接字符串的时候，编译器会选择在<code>StringBuilder</code>中进行拼接，以节约空间。</p><p><code>StringBuilder</code> 的方法<strong>不是</strong>线程安全的（不能同步访问）。由于 <code>StringBuilder</code> 相较于 <code>StringBuffer</code> 有<strong>速度</strong>优势，所以多数情况下建议使用 <code>StringBuilder</code> 类。两者<strong>接口相同</strong>。然而在应用程序要求线程安全的情况下，则必须使用 <code>StringBuffer</code> 类。</p><p>以上两者都支持<strong>链式操作</strong>，原因是支持链式操作的方法都是返回了this&mldr;</p><p>感觉这个和之前写<code>qqbot</code>的时候，<code>coolq</code>提供的API的方法很像呢，有点<code>golang</code>基础看这个舒服多了。</p><pre><code class=language-java>public class Main {
    public static void main(String[] args) {
        var sb = new StringBuilder(1024);
        sb.append(&quot;Mr &quot;)
          .append(&quot;Bob&quot;)
          .append(&quot;!&quot;)
          .insert(0, &quot;Hello, &quot;);
        System.out.println(sb.toString());
    }
}
</code></pre><h3 id=与equals的区别>‘==’与equals()的区别</h3><p>使用“==”比较字符串，实际上是比较的字符串在内存中的地址。要比较内容只能是使用equals()方法。</p><pre><code class=language-java>String s1 = &quot;abc&quot;;
String s2 = &quot;abc&quot;;
s1 == s2 // true
// 这是因为Java编译器在编译期，会自动把所有相同的字符串当作一个对象放入常量池，自然s1和s2的引用就是相同的
</code></pre><h2 id=拼接字符串>拼接字符串</h2><table><thead><tr><th>拼接方法</th><th>方法解释</th></tr></thead><tbody><tr><td><code>String concat(String str)</code></td><td>将指定字符串连接到此字符串的结尾</td></tr><tr><td><code>String join(String link, String[] arr)</code></td><td>用给定的link字符串连接字符串数组</td></tr></tbody></table><p>在使用<code>join</code>方法的时候，内部实现是通过了一个<code>StringJoin</code>类，这个类是通过<code>StringBuffer</code>实现的。在使用时，可以比join多出一些功能，比如指定拼接后的传的开头与结尾。开头与拼接串，拼接串与结尾，直接连接，不加link，示例如下。</p><pre><code class=language-java>import java.util.StringJoiner;

public class Main {
    public static void main(String[] args) {
        String[] names = {&quot;Bob&quot;, &quot;Alice&quot;, &quot;Grace&quot;};
        var sj = new StringJoiner(&quot;, &quot;, &quot;Hello &quot;, &quot;!&quot;);
        for (String name : names) {
            sj.add(name);
        }
        System.out.println(sj.toString());
    }
} // Hello Bob, Alice, Grace!
</code></pre><h2 id=类型转化>类型转化</h2><h3 id=一般类型转换>一般类型转换</h3><pre><code class=language-java>// 返回给定data type类型x参数的字符串表示形式
static String valueOf(primitive data type x)
String.valueOf(45.67); // &quot;45.67&quot;

// 字符串转换为int类型
int n1 = Integer.parseInt(&quot;123&quot;); // 123
int n2 = Integer.parseInt(&quot;ff&quot;, 16); // 按十六进制转换，255

// 把字符串转换为boolean类型
boolean b1 = Boolean.parseBoolean(&quot;true&quot;); // true
boolean b2 = Boolean.parseBoolean(&quot;FALSE&quot;); // false
</code></pre><p>要特别注意，<code>Integer</code>有个<code>getInteger(String)</code>方法，它<strong>不是</strong>将字符串转换为<code>int</code>，而是把该字符串对应的系统变量转换为<code>Integer</code></p><pre><code class=language-java>Integer.getInteger(&quot;java.version&quot;); // 版本号，11
</code></pre><h3 id=char与string类型转换>char[]与String类型转换</h3><pre><code class=language-java>char[] cs = &quot;Hello&quot;.toCharArray(); // String -&gt; char[]
String s = new String(cs); // char[] -&gt; String
</code></pre><p>通过char[]转出时String，是复制了一份char[]数组，修改外部char[]不会影响String中的char[]。</p><h2 id=提取子串>提取子串</h2><table><thead><tr><th>提取子串方法</th><th>方法解释</th></tr></thead><tbody><tr><td><code>String substring(int beginIndex)</code></td><td>返回一个新的字符串，它是此字符串的一个子字符串</td></tr><tr><td><code>String substring(int beginIndex, int endIndex)</code></td><td>返回一个新字符串，它是此字符串的一个子字符串</td></tr></tbody></table><h2 id=编码>编码</h2><p>手动转变编码</p><pre><code class=language-java>byte[] b1 = &quot;Hello&quot;.getBytes(); // 按系统默认编码转换，不推荐
byte[] b2 = &quot;Hello&quot;.getBytes(&quot;UTF-8&quot;); // 按UTF-8编码转换
byte[] b2 = &quot;Hello&quot;.getBytes(&quot;GBK&quot;); // 按GBK编码转换
byte[] b3 = &quot;Hello&quot;.getBytes(StandardCharsets.UTF_8); // 按UTF-8编码转换
</code></pre><p>转换编码后，就不再是<code>char</code>类型，而是<code>byte</code>类型表示的<strong>数组</strong></p><pre><code class=language-java>// 从 byte 数组转换回 String
String s1 = new String(b, &quot;GBK&quot;); // 按GBK转换
String s2 = new String(b, StandardCharsets.UTF_8); // 按UTF-8转换
</code></pre><h2 id=去除首位空白字符>去除首位空白字符</h2><table><thead><tr><th>去除首位空白字符方法</th><th>方法描述</th></tr></thead><tbody><tr><td><code>String trim()</code></td><td>返回字符串的副本，忽略前导和尾部的空白</td></tr><tr><td><code>String strip()</code></td><td>同上，但是去除类似中文空格字符<code>\u3000</code></td></tr><tr><td><code>String stripLeading()</code></td><td>同上，只忽略前导空白</td></tr><tr><td><code>String stripTrailing()</code></td><td>同上，只忽略尾部空白</td></tr></tbody></table><h2 id=判断是否为空>判断是否为空</h2><p>注意区别blank与empty的区别，前者为<strong>只包含空白字符</strong>，后者为<strong>长度为零</strong></p><pre><code class=language-java>&quot;&quot;.isEmpty(); // true，因为字符串长度为0
&quot;  &quot;.isEmpty(); // false，因为字符串长度不为0
&quot;  \n&quot;.isBlank(); // true，因为只包含空白字符
&quot; Hello &quot;.isBlank(); // false，因为包含非空白字符
</code></pre><h2 id=正则表达式相关>正则表达式相关</h2><table><thead><tr><th>正则表达式相关方法</th><th>方法解释</th></tr></thead><tbody><tr><td><code>boolean matches(String regex)</code></td><td>告知此字符串是否匹配给定的正则表达式。</td></tr><tr><td><code>String replaceAll(String regex, String replacement)</code></td><td>用给定的串替换<strong>所有</strong>匹配给定的正则表达式的子字符串</td></tr><tr><td><code>String replaceFirst(String regex, String replacement)</code></td><td>用给定的串替换<strong>首个</strong>匹配给定的正则表达式的子字符串</td></tr><tr><td><code>String[] split(String regex)</code></td><td>根据给定正则表达式的匹配拆分此字符串</td></tr></tbody></table><p>一般的普通替换可以使用</p><pre><code class=language-java>String replace(char oldChar, char newChar) 
// 返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。
</code></pre><h2 id=子串索引>子串索引</h2><table><thead><tr><th>子串索引方法</th><th>方法解释</th></tr></thead><tbody><tr><td><code>int indexOf(int ch)</code></td><td>返回指定字符在此字符串中第一次出现处的索引。</td></tr><tr><td><code>int indexOf(int ch, int fromIndex)</code></td><td>同上，从指定的索引开始搜索。</td></tr><tr><td><code>int indexOf(String str)</code></td><td>返回指定子字符串在此字符串中第一次出现处的索引。</td></tr><tr><td><code>int indexOf(String str, int fromIndex)</code></td><td>同上，从指定的索引开始。</td></tr><tr><td></td><td></td></tr><tr><td><code>int lastIndexOf(int ch)</code></td><td>返回指定字符在此字符串中最后一次出现处的索引。</td></tr><tr><td><code>int lastIndexOf(int ch, int fromIndex)</code></td><td>同上，从指定的索引处开始进行反向搜索。</td></tr><tr><td><code>int lastIndexOf(String str)</code></td><td>返回指定子字符串在此字符串中最右边出现处的索引。</td></tr><tr><td><code>int lastIndexOf(String str, int fromIndex)</code></td><td>同上，从指定的索引开始反向搜索。</td></tr><tr><td></td><td></td></tr><tr><td><code>boolean startsWith(String prefix)</code></td><td>测试此字符串是否以指定的前缀开始</td></tr><tr><td><code>boolean endsWith(String suffix)</code></td><td>测试此字符串是否以指定的后缀结束</td></tr></tbody></table><h2 id=其他常用无参数方法>其他常用无参数方法</h2><table><thead><tr><th>常用无参数方法</th><th>方法解释</th></tr></thead><tbody><tr><td><code>String toLowerCase()</code></td><td>使用默认语言环境的规则将此 String 中的所有字符都转换为小写</td></tr><tr><td><code>String toUpperCase()</code></td><td>使用默认语言环境的规则将此 String 中的所有字符都转换为大写。</td></tr><tr><td><code>int hashCode()</code></td><td>返回此字符串的哈希码</td></tr><tr><td><code>int length()</code></td><td>返回此字符串的长度</td></tr></tbody></table><h2 id=其他内容>其他内容</h2><p>早期JDK版本中，<code>String</code> 总是以 <code>char[]</code> 存储的，而较新版本JDK下的 <code>String</code> 是以 <code>byte[]</code> 存储的。如果<code>String</code>仅包含ASCII字符，则每个<code>byte</code>存储一个字符，否则，每两个<code>byte</code>存储一个字符，这样做的目的是为了节省内存，因为大量的长度较短的<code>String</code>通常仅包含ASCII字符</p><p>对于使用者来说，<code>String</code>内部的优化不影响任何已有代码，因为它的<code>public</code>方法签名是不变的。</p><h1 id=包装类型>包装类型</h1><p>Java有内置的，将基本类型包装为引用类型的类</p><table><thead><tr><th style=text-align:left>基本类型</th><th style=text-align:left>对应的引用类型</th></tr></thead><tbody><tr><td style=text-align:left><code>boolean</code></td><td style=text-align:left><code>java.lang.Boolean</code></td></tr><tr><td style=text-align:left><code>byte</code></td><td style=text-align:left><code>java.lang.Byte</code></td></tr><tr><td style=text-align:left><code>short</code></td><td style=text-align:left><code>java.lang.Short</code></td></tr><tr><td style=text-align:left><code>int</code></td><td style=text-align:left><code>java.lang.Integer</code></td></tr><tr><td style=text-align:left><code>long</code></td><td style=text-align:left><code>java.lang.Long</code></td></tr><tr><td style=text-align:left><code>float</code></td><td style=text-align:left><code>java.lang.Float</code></td></tr><tr><td style=text-align:left>double`</td><td style=text-align:left><code>java.lang.Double</code></td></tr><tr><td style=text-align:left><code>char</code></td><td style=text-align:left><code>java.lang.Character</code></td></tr></tbody></table><h2 id=创建包装类型>创建包装类型</h2><pre><code class=language-java>int i = 100;
// 通过new操作符创建Integer实例(不推荐使用,会有编译警告):
Integer n1 = new Integer(i);
// 通过静态方法valueOf(int)创建Integer实例:
Integer n2 = Integer.valueOf(i);
// 通过静态方法valueOf(String)创建Integer实例:
Integer n3 = Integer.valueOf(&quot;100&quot;);
</code></pre><p>使用<code>valueOf</code>方法的时候，是把创建实例的工作留给<code>Integer</code>类内部去做，这些东西有可能会进行了优化，比直接使用new更优。我们把能创建“新”对象的静态方法称为<strong>静态工厂方法</strong>。<code>Integer.valueOf()</code>就是静态工厂方法，它尽可能地返回缓存的实例以节省内存；而直接使用new不是方法，更不是静态工厂方法。</p><h2 id=auto-boxing>Auto Boxing</h2><pre><code class=language-java>Integer n = 100; // 编译器自动使用Integer.valueOf(int)
int x = n; // 编译器自动使用Integer.intValue()
</code></pre><p>这样直接完成的，从基本类型到引用类型的转换叫做<strong>自动装箱(Auto Boxing)</strong>，反向地，从引用类型到基本类型叫做<strong>自动拆箱(Auto Unboxing)</strong>。这两个过程只发生在编译阶段（这句话没怎么看懂），目的是为了少些代码。但是装箱与拆箱会<strong>影响代码执行效率</strong>，因为在编译之后，这两个东西是完全区分开的，而且，由于引用类型可以有<code>null</code>值，所以在自动拆箱的时候还有可能产生<code>NullPointerException</code>。</p><h2 id=不变类>不变类</h2><p>所有的包装类型都是<strong>不变类</strong>，也就是源码中设置的<code>private final int value</code>，一旦创建，无法改变。</p><p>在比较包装类型的内容的时候，必须要使用<code>equals()</code>方法。此时使用<code>==</code>有些可以达成目的，原理同String类比较。</p><h2 id=数的类型转换>数的类型转换</h2><p>所有的整数和浮点数的包装类型<strong>都继承自</strong><code>Number</code>，因此，可以非常方便地直接通过包装类型获取各种基本类型</p><pre><code class=language-java>// 向上转型为Number:
Number num = new Integer(999);
// 获取byte, int, long, float, double:
byte b = num.byteValue();
int n = num.intValue();
long ln = num.longValue();
float f = num.floatValue();
double d = num.doubleValue();
</code></pre><h2 id=integer类>Integer类</h2><h3 id=进制转换>进制转换</h3><pre><code class=language-java>Integer.toString(100) // &quot;100&quot;,表示为10进制
Integer.toString(100, 36) // &quot;2s&quot;,表示为36进制
(Integer.toHexString(100) // &quot;64&quot;,表示为16进制
Integer.toOctalString(100) // &quot;144&quot;,表示为8进制
Integer.toBinaryString(100) // &quot;1100100&quot;,表示为2进制
</code></pre><p>上述方法输出的都是String。</p><h3 id=字符串解析整数>字符串解析整数</h3><pre><code class=language-java>int x1 = Integer.parseInt(&quot;100&quot;); // 100
int x2 = Integer.parseInt(&quot;100&quot;, 16); // 256,因为按16进制解析
</code></pre><h3 id=常用静态变量>常用静态变量</h3><pre><code class=language-java>// int可表示的最大/最小值:
int max = Integer.MAX_VALUE; // 2147483647
int min = Integer.MIN_VALUE; // -2147483648
// long类型占用的bit和byte数量:
int sizeOfLong = Integer.SIZE; // 64 (bits)
int bytesOfLong = Integer.BYTES; // 8 (bytes)
</code></pre><h2 id=boolean类>Boolean类</h2><pre><code class=language-java>// boolean只有两个值true/false，其包装类型只需要引用Boolean提供的静态字段:
Boolean t = Boolean.TRUE;
Boolean f = Boolean.FALSE;
</code></pre><h2 id=无符号整型>无符号整型</h2><p>Java中<strong>没有</strong>提供无符号整型(Unsigned)的基本数据类型。但是通过包装类型中给出的方法进行转化，以 Byte 为例。</p><pre><code class=language-java>byte x = -1;
byte y = 127;
Byte.toUnsignedInt(x) // 255
Byte.toUnsignedInt(y) // 127
</code></pre><p>注意 -1 转换之后变成了255，原因是以补码保存整数。</p><h1 id=javabean>JavaBean</h1><p>如果读写方法符合以下这种命名规范：</p><pre><code class=language-java>// 读方法:
public Type getXyz()
// 写方法:
public void setXyz(Type value)
</code></pre><p>那么这种<code>class</code>被称为<code>JavaBean</code>。</p><p><code>boolean</code>字段比较特殊，它的读方法一般命名为<code>isXyz()</code></p><p>我们通常把一组对应的读方法（<code>getter</code>）和写方法（<code>setter</code>）称为属性（<code>property</code>）。例如，<code>name</code>属性：</p><ul><li>对应的读方法是<code>String getName()</code>只有<code>getter</code>的属性称为只读属性（read-only）</li><li>对应的写方法是<code>setName(String)</code></li></ul><p>属性只需要定义<code>getter</code>和<code>setter</code>方法，不一定需要对应的字段，也可以是通过已有字段计算得到。</p><p>可以看出，<code>getter</code>和<code>setter</code>也是一种数据封装的方法。</p><h2 id=作用>作用</h2><p>主要用来传递数据，即把一组数据组合成一个JavaBean便于传输。此外，JavaBean可以方便地被IDE工具分析，生成读写属性的代码，主要用在图形界面的可视化设计中。</p><h2 id=其他>其他</h2><p>通过IDE，可以快速生成<code>getter</code>和<code>setter</code>。</p><pre><code class=language-java>// 要枚举一个JavaBean的所有属性，可以直接使用Java核心库提供的Introspector
import java.beans.*;
public class Main {
    public static void main(String[] args) throws Exception {
        BeanInfo info = Introspector.getBeanInfo(Person.class);
        for (PropertyDescriptor pd : info.getPropertyDescriptors()) {
            System.out.println(pd.getName());
            System.out.println(&quot;  &quot; + pd.getReadMethod());
            System.out.println(&quot;  &quot; + pd.getWriteMethod());
        }
    }
}

class Person {
    private String name;
    private int age;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
</code></pre><h1 id=枚举类>枚举类</h1><p>枚举类型的定义与C语言中相似，可以使用<code>enum</code>来的定义。但是在其他方面有一些不同。</p><p>比较的时候要使用<code>equals()</code>方法，原因同前。但是也可以使用<code>==</code>， 因为<code>enum</code>类型的每个常量在<code>JVM</code>中只有一个唯一实例，所以可以直接使用<code>==</code>比较。编译后的<code>enum</code>类与普通的<code>class</code>类<strong>没有区别</strong>，每个常量是全局唯一，即<code>static final</code>修饰。比较之下有以下特点：</p><ul><li>定义的<code>enum</code>类型总是继承自<code>java.lang.Enum</code>，且<strong>无法被继承</strong></li><li>只能定义出<code>enum</code>的实例，而<strong>无法</strong>通过<code>new</code>操作符创建<code>enum</code>的实例</li><li>定义的每个实例都是引用类型的<strong>唯一实例</strong></li><li>可以将<code>enum</code>类型用于<code>switch</code>语句</li></ul><h2 id=常用方法>常用方法</h2><p>在已定义如下的枚举类的背景下：</p><pre><code class=language-java>enum Weekday {
    SUN, MON, TUE, WED, THU, FRI, SAT;
}
</code></pre><table><thead><tr><th>常用方法</th><th>方法解释</th></tr></thead><tbody><tr><td><code>name()</code></td><td>返回常量名，该方法不可覆写</td></tr><tr><td><code>ordinal()</code></td><td>返回定义的常量的顺序，从0开始计数</td></tr><tr><td><code>toString()</code></td><td>返回和name一样的字符串，但是这个方法可以覆写</td></tr></tbody></table><p><strong>注意</strong>常量的 ordinal 与常量的定义顺序密切相关，容易出错，可以定义<code>private</code>的构造方法，在内部使用。</p><pre><code class=language-java>enum Weekday {
    MON(1, &quot;星期一&quot;), TUE(2, &quot;星期二&quot;), WED(3, &quot;星期三&quot;), THU(4, &quot;星期四&quot;), FRI(5, &quot;星期五&quot;), SAT(6, &quot;星期六&quot;), SUN(0, &quot;星期日&quot;);

    public final int dayValue;
    private final String chinese;

    private Weekday(int dayValue, String chinese) {
        this.dayValue = dayValue;
        this.chinese = chinese;
    }

    @Override
    public String toString() {
        return this.chinese;
    }
}
</code></pre><p>覆写<code>toString()</code>的目的是在输出时更有可读性</p><h3 id=使用场景>使用场景</h3><p>与<code>switch</code>语句搭配使用，同C语言。记得加上<code>default</code>语句，可以在漏写某个枚举常量的时候自动报错，及时发现错误。</p><h1 id=记录类>记录类</h1><p><code>Java14</code>的新特性，一行写出不变类的定义。这里写一点例子吧，要是以后需要再去细看。</p><pre><code class=language-java>public record Point(int x, int y) {}
</code></pre><p>上文相当于写出了</p><pre><code class=language-java>public final class Point extends Record {
    private final int x;
    private final int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int x() {
        return this.x;
    }

    public int y() {
        return this.y;
    }

    public String toString() {
        return String.format(&quot;Point[x=%s, y=%s]&quot;, x, y);
    }

    public boolean equals(Object o) {
        ...
    }
    public int hashCode() {
        ...
    }
}
</code></pre><p>可以加上检查逻辑，检查构造方法传入的参数是否正确。</p><pre><code class=language-java>public record Point(int x, int y) {
    public Point {
        if (x &lt; 0 || y &lt; 0) {
            throw new IllegalArgumentException();
        }
    }
}
</code></pre><p>此外，在<code>record</code>方法中，还可以新定义静态方法。</p><h1 id=biginteger>BigInteger</h1><p>Java牛逼，内置高精度！废话不说了，直接上例子吧</p><pre><code class=language-java>import java.math.BigInteger;

BigInteger bi = new BigInteger(&quot;1234567890&quot;);
System.out.println(bi.pow(5)); // 2867971860299718107233761438093672048294900000
</code></pre><p>对大整数类做运算，只能使用实例方法了，支持<strong>链式操作</strong>，支持加减乘除平方。</p><p>将大整数类型转换为基本类型的时候，尽量使用exact的方法，比如<code>intValueExact()</code>，如果内容已经<strong>超</strong>过了基本类型的范围，整数会返回<code>ArithmeticException</code>，而浮点数会返回<code>Infinity</code>之类的东西。下面列举的这些，可以强行转换，但是会舍弃超出的高位，有时会有严重问题，谨慎。</p><ul><li>转换为<code>byte</code>：<code>byteValue()</code></li><li>转换为<code>short</code>：<code>shortValue()</code></li><li>转换为<code>int</code>：<code>intValue()</code></li><li>转换为<code>long</code>：<code>longValue()</code></li><li>转换为<code>float</code>：<code>floatValue()</code></li><li>转换为<code>double</code>：<code>doubleValue()</code></li></ul><h1 id=bigdecimal>BigDecimal</h1><p>高精度浮点数！不，不是，是任意大小，<strong>精度完全准确</strong>的浮点数！</p><pre><code class=language-java>import java.math.BigDecimal;
import java.math.RoundingMode;

BigDecimal d1 = new BigDecimal(&quot;123.4500&quot;);
BigDecimal d2 = d1.stripTrailingZeros();
System.out.println(d1.scale()); // 4
System.out.println(d2.scale()); // 2,因为去掉了00

BigDecimal d3 = new BigDecimal(&quot;1234500&quot;);
BigDecimal d4 = d3.stripTrailingZeros();
System.out.println(d3.scale()); // 0
System.out.println(d4.scale()); // -2，表示是个整数，后面有两个0

BigDecimal d1 = new BigDecimal(&quot;123.456789&quot;);
BigDecimal d2 = d1.setScale(4, RoundingMode.HALF_UP); // 四舍五入，123.4568
BigDecimal d3 = d1.setScale(4, RoundingMode.DOWN); // 直接截断，123.4567

BigDecimal d1 = new BigDecimal(&quot;123.456&quot;);
BigDecimal d2 = new BigDecimal(&quot;23.456789&quot;);
BigDecimal d3 = d1.divide(d2, 10, RoundingMode.HALF_UP); // 保留10位小数并四舍五入
BigDecimal d4 = d1.divide(d2); // 报错：ArithmeticException，因为除不尽

BigDecimal n = new BigDecimal(&quot;12.345&quot;);
BigDecimal m = new BigDecimal(&quot;0.12&quot;);
BigDecimal[] dr = n.divideAndRemainder(m);
System.out.println(dr[0]); // 102
System.out.println(dr[1]); // 0.105
// 返回的数组包含两个BigDecimal，分别是商和余数，其中商总是整数，余数不会大于除数。我们可以利用这个方法判断两个BigDecimal是否是整数倍数
</code></pre><p>在比较两个<code>BigDecimal</code>的值是否相等时，要特别注意，使用<code>equals()</code>方法<strong>不但要求</strong>两个<code>BigDecimal</code>的值相等，<strong>还要求</strong>它们的<code>scale()</code>相等。<strong>必须</strong>使用<code>compareTo()</code>方法来比较，它根据两个值的大小分别返回负数、正数和<code>0</code>，分别表示小于、大于和等于。</p><h1 id=常用工具类>常用工具类</h1><h2 id=math>Math</h2><h3 id=静态方法>静态方法</h3><pre><code class=language-java>Math.abs(-100); // 100
Math.abs(-7.8); // 7.8

Math.max(100, 99); // 100
Math.min(1.2, 2.3); // 1.2

Math.pow(2, 10); // 2的10次方=1024
Math.sqrt(2); // 1.414...

Math.exp(2); // 7.389...
Math.log(4); // 1.386...
Math.log10(100); // 2

Math.sin(3.14); // 0.00159...
Math.cos(3.14); // -0.9999...
Math.tan(3.14); // -0.0015...
Math.asin(1.0); // 1.57079...
Math.acos(1.0); // 0.0
</code></pre><h3 id=数学常量>数学常量</h3><pre><code class=language-java>double pi = Math.PI; // 3.14159...
double e = Math.E; // 2.7182818...
Math.random(); // 0.53907... 每次都不一样 范围是[0,1)
</code></pre><h3 id=strictmath>StrictMath</h3><p>Java标准库还提供了一个<code>StrictMath</code>，它提供了和<code>Math</code>几乎一模一样的方法。这两个类的区别在于，由于浮点数计算存在<strong>误差</strong>，不同的平台（例如x86和ARM）计算的结果可能不一致（指误差不同），因此，<code>StrictMath</code><strong>保证所有平台计算结果都是完全相同的</strong>，而<code>Math</code>会尽量针对平台<strong>优化计算速度</strong>，所以，绝大多数情况下，使用<code>Math</code>就足够了。</p><h2 id=random>Random</h2><pre><code class=language-java>import java.util.Random;

Random r = new Random(); 
// 如果不给定种子，就使用系统当前时间戳作为种子，因此每次运行时，种子不同，得到的伪随机数序列就不同。
r.nextInt(); // 2071575453,每次都不一样
r.nextInt(10); // 5,生成一个[0,10)之间的int
r.nextLong(); // 8811649292570369305,每次都不一样
r.nextFloat(); // 0.54335...生成一个[0,1)之间的float
r.nextDouble(); // 0.3716...生成一个[0,1)之间的double
</code></pre><p>Math 中使用的随机数random就是调用的这个库</p><h2 id=securerandom>SecureRandom</h2><p>上面随机数的加强版，使用RNG（random number generator）算法。</p><p>JDK的<code>SecureRandom</code>实际上有多种不同的底层实现，有的使用安全随机种子加上伪随机数算法来产生安全的随机数，有的使用真正的随机数生成器。实际使用的时候，可以优先获取高强度的安全随机数生成器，如果没有提供，再使用普通等级的安全随机数生成器。</p><p><code>SecureRandom</code>的安全性是通过<strong>操作系统提供的安全的随机种子</strong>来生成随机数。这个种子是通过<strong>CPU的热噪声</strong>、<strong>读写磁盘的字节</strong>、<strong>网络流量</strong>等各种<strong>随机事件</strong>产生的“熵”。在<strong>密码学</strong>中，安全的随机数非常重要。如果使用不安全的伪随机数，所有加密体系都将被攻破。因此，时刻牢记必须使用<code>SecureRandom</code>来产生安全的随机数。</p><pre><code class=language-java>import java.util.Arrays;
import java.security.SecureRandom;
import java.security.NoSuchAlgorithmException;

public class Main {
    public static void main(String[] args) {
        SecureRandom sr = null;
        try {
            sr = SecureRandom.getInstanceStrong(); // 获取高强度安全随机数生成器
        } catch (NoSuchAlgorithmException e) {
            sr = new SecureRandom(); // 获取普通的安全随机数生成器
        }
        byte[] buffer = new byte[16];
        sr.nextBytes(buffer); // 用安全随机数填充buffer
        System.out.println(Arrays.toString(buffer));
    }
}
</code></pre></div><div class=article-footer><blockquote class=mt-2x><ul class="post-copyright list-unstyled"><li class="post-copyright-link hidden-xs"><strong>本文链接:</strong>
<a href=https://qeryu.github.io/2020/03/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%A0%B8%E5%BF%83%E7%B1%BB/ title=Java学习笔记——核心类 target=_blank rel=external>https://qeryu.github.io/2020/03/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%A0%B8%E5%BF%83%E7%B1%BB/</a></li><li class=post-copyright-license><strong>License:</strong>
<a href=http://creativecommons.org/licenses/by/4.0/deed.zh target=_blank rel=external>CC BY 4.0 CN</a></li></ul></blockquote><div class="panel panel-default panel-badger"><div class=panel-body><figure class=media><div class=media-left><a href=https://github.com/qeryu target=_blank class="img-burn thumb-sm visible-lg"><img src=https://qeryu.github.io/avatar/qeryu.jpg class="img-rounded w-full" alt></a></div><div class=media-body><h3 class=media-heading><a href=https://github.com/qeryu target=_blank><span class=text-dark>Qeryu</span><small class=ml-1x>信息安全学生</small></a></h3><div>Good Good Study, Day Day Up~</div></div></figure></div></div></div></article></div><nav class="bar bar-footer clearfix" data-stick-bottom><div class=bar-inner><ul class="pager pull-left"><li class=prev><a href=https://qeryu.github.io/2020/03/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/ title=Java学习笔记——面向对象><i class="icon icon-angle-left" aria-hidden=true></i><span>&nbsp;&nbsp;下一篇</span></a></li><li class=next><a href=https://qeryu.github.io/2020/03/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0maven/ title=Java学习笔记——Maven><span>上一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden=true></i></a></li><li class=toggle-toc><a class="toggle-btn collapsed" data-toggle=collapse href=#collapseToc aria-expanded=false title=文章目录 role=button><span>[&nbsp;</span><span>文章目录</span>
<i class="text-collapsed icon icon-anchor"></i>
<i class="text-in icon icon-close"></i>
<span>]</span></a></li></ul><div class=bar-right><div class=share-component data-sites=weibo,qq,wechat,facebook,twitter data-mobile-sites=weibo,qq,qzone></div></div></div></nav></main><footer class=footer itemscope itemtype=http://schema.org/WPFooter><ul class=social-links><li><a href=https://github.com/qeryu target=_blank title=github data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li><li><a href=https://qeryu.github.io/index.xml target=_blank title=rss data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li></ul><div class=copyright>&copy;2019 -
2022<div class=publishby>Theme by <a href=https://github.com/xiaoheiAh target=_blank>xiaoheiAh </a>base on<a href=https://github.com/xiaoheiAh/hugo-theme-pure target=_blank> pure</a>.</div></div></footer><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script>
<script type=text/x-mathjax-config>
    MathJax.Hub.Config({
            showMathMenu: false, //disables context menu
            tex2jax: {
            inlineMath: [ ['$','$'], ['\\(','\\)'] ]
           }
    });
</script><script src=https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js></script>
<script>window.jQuery||document.write('<script src="js/jquery.min.js"><\/script>')</script><script type=text/javascript src=https://cdn.staticfile.org/highlight.js/9.15.10/highlight.min.js></script>
<script type=text/javascript src=https://cdn.staticfile.org/highlight.js/9.15.10/languages/python.min.js defer></script>
<script type=text/javascript src=https://cdn.staticfile.org/highlight.js/9.15.10/languages/javascript.min.js defer></script><script>hljs.configure({tabReplace:"    ",classPrefix:''}),hljs.initHighlightingOnLoad()</script>
<script src=https://qeryu.github.io/js/application.min.c181e6b0c036798c7731cfb85b41b44c80689fd48fee546b73d449386ce6ccfb.js></script>
<script src=https://qeryu.github.io/js/plugin.min.cf6ab047215536635a92ff5defe1e5174ee0acd6c4950757b2732693f7f196f3.js></script>
<script>(function(e){var t={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(未命名)"},ROOT_URL:"https://qeryu.github.io/",CONTENT_URL:"https://qeryu.github.io//searchindex.json "};e.INSIGHT_CONFIG=t})(window)</script><script type=text/javascript src=https://qeryu.github.io/js/insight.min.853c5d4062a8c262b2490c70df2f6d2b232483f85227b30b28013788b8c4da8ab59c1a735b9b31c9006f2962ef62213fea9d17cb9469c297f201772ce94e8fdf.js defer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js></script>
<script>tocbot.init({tocSelector:".js-toc",contentSelector:".js-toc-content",headingSelector:"h1, h2, h3",hasInnerContainers:!0})</script></body></html>